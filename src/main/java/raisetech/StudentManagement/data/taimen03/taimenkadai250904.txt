-------------------------------------------------------------------------------
■課題１
現在の一覧表示に検索機能を実装したいです。
検索を行うにあたって必要な処理は何かを、以下の項目に沿って書き出してみましょう。
(可能であれば実装まで試してみましょう。)
ChatGPTなどの生成ＡＩも活用しても問題ありません。
＜書き出す項目＞
1.検索処理のHTTPメソッドは何を用いるか考えましょう。
　※検索機能では主にどのメソッドを用いるのが一般的か、理由も簡単に考えてみましょう。
2.名前"name"というパラメータで検索を行う場合に、リクエストするURLはどのような形に
　なるか記述しましょう。（例：'/students?name=○○'のような形で記述）
3.SpringBootにおいて、この場合のリクエストを受け取るControllerのアノテーションには
　何を用いるか書き出しましょう。
4.nameで検索を行う際のSQLはどんな文法（予約語）が用いられるか考えましょう。
-------------------------------------------------------------------------------
＜回答＞
1.GET or POST どちらがよいか?理由は?
GET :サーバーからデータを取得する機能を使用するため

2.http://localhost:8080/（ここにURLの続きを書く）
http://localhost:8080/students?name=#{name}

3.1の答えに対応するアノテーション
@GetMapping

4.対応したSELECT文
SELECT * FROM student WHERE name = #{name};

-------------------------------------------------------------------------------
＜解説＞
書き出した各項目に対して、以下が入っていればOK。
1.GET
2.http://localhost:8080/students?name=****
  (****のところは任意でOKです)
3.@GetMapping
4.SELECT * FROM students WHERE name = '****';

＜補足コメント＞
検索でGETメソッドを使用する理由は、データに操作を加えない（安全）かつ、リソース
が同じであれば何度操作を行っても同じ結果が得られるため。
たとえばGET処理のURLをブックマークに保存すれば、何度でも実行できてしまう。これが
データに操作を加えてしまう処理であれば、何度でも実行されてしまうのは良くない。

＜GETとPOSTの違い＞
・送信データの持ち方
    GET：   URLにすべての送信データを乗せる(URLから見える)
    POST：  リクエストボディーに送信データを乗せる（URLから見えない）

・再現性
    GET：   再現性が高く、何度でも実行される検索処理に向いている。
    POST：  再現性が低く、一度きりの追加、更新、削除処理に向いている。

・curlコマンドでの違い
    GET:    curl "http://localhost:8080/studentInfo?name=YamadaTarou"
    POST:   curl -X POST -d 'name=YamadaTarou&age=50&placeOfBirth=tokyo' "http://localhost:8080/student"

・ChromeのデベロッパーツールでGET、POSTの違いを確認する
    参考）Developer ToolsでPOSTされた値をチェックする
    https://nibutan.hatenablog.com/entry/2024/07/13/075626

とりあえずは、検索ではGET、追加修正削除ではPOSTを使うというイメージでよい。

----------------------------------------------------------------------------

-------------------------------------------------------------------------------
■課題２
受講生情報、受講生コース情報が登録できるようになっている前提で、以下の＞ようにソース
を改変し、データの登録処理を確認しましょう。
・serviceクラスの@Transactionalを削除しましょう。
・受講生情報の登録を実行した後に、任意の例外を出力するようにしましょう。
　確認したのち、@Transactionalを付与して、再度登録処理を行いましょう。
-------------------------------------------------------------------------------
＜回答＞
ヒント：ブレイクポイントとデバッグ実行を活用

-------------------------------------------------------------------------------
＜解説＞
・受講生登録処理の@Transactionalアノテーションをコメントアウトし、コース情報登録処理
　の最初にブレイクポイントを設置して、アプリをデバッグで実行。
・ブレイクポイントで停止したら、studentsCoursesの値をnullに強制変更してエラーを発生させる。
（具体的には、デバッグ＞スレッドと変数＞studentDetail>studentsCoursesを右クリック、
　値の設定＞nullを入力してEnterし、再開ボタンを押す）
・その結果、直前に処理していた受講生登録処理がデータベースに反映されているかどうかを確認する。
・@Transactionalが付与されていないと、受講生情報だけが登録された状態となる。
・@Transactionalが付与されていると、受講生情報の登録は取り消される。そのことで、データの
　整合性が保持される。
＜補足＞
・昔はプログラマーがSQLのcommit、rollbackコマンドを駆使して、プログラム上でトランザクション
　処理を実現していた。今はそれらを自動でやってくれる。
・今でもMySQL上で再現できる。
    参考）【MYSQL】トランザクション処理
    https://qiita.com/Yz6i1NrsEMtuL0f/items/7fbd175d233613271742
・serviceクラスについて
    参考）SpringBoot/各レイヤの責務
    https://cs27.org/wiki/kobespiral2021/?SpringBoot/%E5%90%84%E3%83%AC%E3%82%A4%E3%83%A4%E3%81%AE%E8%B2%AC%E5%8B%99

-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
■課題３
登録処理について、以下のようなSQL文を実行した際の実行結果やエラーメッセージの内容、
idの採番結果を観察しましょう。テーブルは既存のものでも、新たにテスト用に作成した
ものでも構いません。
・Primary Keyとして設定したidにAUTO INCREMENTを付与し、INSERT文でidを指定せずにデ
　ータを５件登録しましょう。
　登録後にidカラムにどのような値が自動採番されているかを確認しましょう。
・上記で登録されたidと同じ値を明示的に指定して、再度INSERT文を実行しましょう。
　どのようなエラーが発生するかを確認し、その原因について考えましょう。
-------------------------------------------------------------------------------
＜回答＞

＜下記のSQLコマンドを実行して確認＞
//MySQL接続
mysql -u root -p
Enter password:****

//データベース一覧表示
show databases;
//データベース作成
create database studentmanagement_taimen2;
//使用データベース指定
use studentmanagement_taimen2;
//テーブル作成
create table student(
id int not null primary key auto_increment,
name varchar(100),
age int
) DEFAULT CHARSET=utf8;

//ここからINSERT文で５件のレコードの登録を行って自動採番の確認、
//idが重複したレコードの登録とエラーの確認を行いましょう。

-------------------------------------------------------------------------------
//レコード作成
insert student(name,age) values('山田太郎',20);
insert student(name,age) values('田中二郎',25);
insert student(name,age) values('佐藤三郎',30);
insert student(name,age) values('鈴木四郎',35);
insert student(name,age) values('山本五郎',40);

//レコード検索の結果、idが自動採番されていることを確認。
select * from student;
+----+----------+------+
| id | name     | age  |
+----+----------+------+
|  1 | 山田太郎 |   20 |
|  2 | 田中二郎 |   25 |
|  3 | 佐藤三郎 |   30 |
|  4 | 鈴木四郎 |   35 |
|  5 | 山本五郎 |   40 |
+----+----------+------+


//id=1でレコード作成すると下記SQLエラーが出ることを確認。
insert student(id, name,age) values(1, '山中六郎',45);

ERROR 1062 (23000): Duplicate entry '1' for key 'student.PRIMARY'

//終わったらデータベースを削除する
drop database studentmanagement_taimen2;
